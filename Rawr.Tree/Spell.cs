using System;

namespace Rawr.Tree
{
    public abstract class Spell
    {
        protected float minHeal = 0f;
        public float MinHeal
        { get { return minHeal + healingBonus * coefDH; } }
        public float BaseMinHeal
        { get { return minHeal; } }
        protected float maxHeal = 0f;
        public float MaxHeal
        { get { return maxHeal + healingBonus * coefDH; } }
        public float BaseMaxHeal
        { get { return maxHeal; } }
        public float castTime = 0f;
        public float castTimeBeforeHaste = 0f;
        public float CastTime
        { 
            get 
            {
                if (castTime > gcd)
                    return castTime;        // Not castTimeBeforeHaste
                else if (gcd > 1)
                    return gcd;
                else
                    return 1;
            }
        }
        public float gcd = 1.5f;
        public float gcdBeforeHaste = 1.5f;
        protected float manaCost = 0f;

        virtual public float ManaCost
        {
            get { return checkOmenlikeProcs(); }
//            set { manaCost = value; }
        }

        public float coefDH = 0f; //coef for DirectHeal
        public float speed = 1;
        public float NGmod = 0;

        protected float healingBonus = 0f;
        virtual public float HealingBonus
        {
            get { return healingBonus; }
            set { healingBonus = value; }
        }

        protected float critModifier = 1.5f;
        public float CritModifier
        {
            get { return critModifier; }
            set { critModifier = value; }
        }

        protected float critPercent = 0f;
        public float CritPercent
        {
            get { return critPercent; }
            set { critPercent = value; }
        }

        protected float periodicTick = 0f;
        protected float periodicTicks = 0f;
        public float PeriodicTicks
        { get { return periodicTicks; } }
        protected float periodicTickTime = 3f;
        public float PeriodicTickTime
        { get { return periodicTickTime; } }
        public float coefHoT = 0f; //coef for HoT

        protected float extraHealing = 0f; // for BonusHoTOnDirectHeals

        virtual public float AverageHealing
        { get { return extraHealing + (minHeal + maxHeal) / 2 + HealingBonus * coefDH; } }

        public float AverageHealingwithCrit
        { get { return (AverageHealing * (100 - critPercent) + (AverageHealing * critModifier) * critPercent) / 100; } }

        virtual public float PeriodicTick
        { get { return periodicTick + healingBonus * coefHoT; } }

        // Direct Healing divided per cast time
        virtual public float HPS                                
        { get { return AverageHealingwithCrit / CastTime; } }

        // Rate at which HoT healing is applied
        //   Different from the rate at which it can be generated by the druid (see HPCT)
        public float HPSHoT                                     
        { get { return (PeriodicTick) / periodicTickTime; } }

        // Total healing generated by this spell, includes base, crit and HoT effects
        public float TotalAverageHealing
        { get { return (AverageHealingwithCrit + PeriodicTick * PeriodicTicks); } }

        public float HPM
        { get { return (TotalAverageHealing) / ManaCost; } }

        // Wildebees: 20090221 : Healing per cast time, considers direct healing and HoT parts
        //     Total healing divided by CastTime
        // This indicates the rate at which the healing is generated
        public float HPCT
        { get { return (TotalAverageHealing) / CastTime; } }

        public float Duration
        { get { return periodicTicks * periodicTickTime; } }

        private Stats cachedStats;  // Keep a local copy of stats used to create spell

        public void Initialize(CharacterCalculationsTree calcs, Stats calculatedStats)
        {
            speed = (1 + (calculatedStats.HasteRating) / TreeConstants.HasteRatingToHaste);
            speed *= (1 + calculatedStats.SpellHaste);
            critModifier *= 1f + calculatedStats.BonusCritHealMultiplier;
            NGmod = calcs.LocalCharacter.DruidTalents.NaturesGrace / 3f;
            extraHealing = calculatedStats.BonusHealingReceived;
            cachedStats = calculatedStats;
            applyHaste();
        }

        public virtual void calculateOldNaturesGrace(float critChance)
        {
            if (castTimeBeforeHaste > 0)
            {
                castTimeBeforeHaste -= NGmod * critChance * 0.5f;
                applyHaste();
            }
        }

        public virtual void calculateNewNaturesGrace(float critChance)
        {
            if (castTimeBeforeHaste > 0)
            {
                applyHaste(); // calculate cast time
                /**
                 * Actually, if you have low primary heal usage, this will be a lot less!
                 * But! Often, primary heal usage is bursty in nature.
                 * spellsAffected = (int)(3f / castTime)
                 */
                float pNoBuff = 1f;
                for (int k = 0; k < 3f / castTime; k++)
                {
                    pNoBuff *= 1 - NGmod * critChance;
                }
                speed *= ( (1 - pNoBuff) * 0.2f) + 1f;
                applyHaste();
            }
        }
        
        protected virtual void applyHaste()
        {
            gcd = gcdBeforeHaste / speed;
            castTime = (float)Math.Round(castTimeBeforeHaste / speed, 4);
        }

        protected float OmenProc(float chance, float maxReduction)
        {
            if (manaCost < maxReduction)
                return manaCost * (1.0f - chance);
            else
            {
                return manaCost * (1.0f - chance) + chance * (manaCost - maxReduction);
            }
        }

        protected float checkOmenlikeProcs() 
        {
            float newManaCost = manaCost;

            //Attempt to handle new SpecialEffect for this
            foreach (Rawr.SpecialEffect effect in cachedStats.SpecialEffects())
            {
               if (effect.Trigger == Trigger.SpellCast && (effect.Stats.ManacostReduceWithin15OnHealingCast > 0))
                   newManaCost = OmenProc(effect.Chance, effect.Stats.ManacostReduceWithin15OnHealingCast);
            }

            // Handle case of stat not being created as a SpecialEffect
            if (cachedStats.ManacostReduceWithin15OnHealingCast > 0)
                newManaCost = OmenProc(0.02f, cachedStats.ManacostReduceWithin15OnHealingCast);

            return newManaCost;
        }
    }

    /*
     * Healing Touch updated Jan 12th 2009 by Trolando
     * Using Resto Spreadsheet v1.21L, WoWHead.com, WoWWiki.com
     */
    public class HealingTouch : Spell
    {
        public HealingTouch(CharacterCalculationsTree calcs, Stats calculatedStats)
        {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 3f;
            coefDH = 1.62f;
            manaCost = 0.33f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;
            critPercent = calculatedStats.SpellCrit;

            minHeal = 3750f;
            maxHeal = 4428f;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            #region Glyph of Healing Touch
            if (calcs.LocalCharacter.DruidTalents.GlyphOfHealingTouch) //(calcOpts.glyphOfHealingTouch)
            {
                castTimeBeforeHaste -= 1.5f;
                manaCost *= 1 - 0.25f;
                minHeal *= 1 - 0.5f;
                maxHeal *= 1 - 0.5f;
                coefDH *= 1 - 0.5f;
            }
            #endregion

            #region Idols
            //guessed that it doesnt work with talents
            //z.B.: Idol of the Avian Heart (+136 Healing)
            healingBonus += calculatedStats.HealingTouchFinalHealBonus;

            //z.B.: Idol of Longevity (25 Mana on cast.... -25 Manacost)
            manaCost -= calculatedStats.ReduceHealingTouchCost;
            #endregion

            

            applyHaste();
        }

        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts)
        {
            manaCost *= 1 - (druidTalents.Moonglow * 0.03f + druidTalents.TranquilSpirit * 0.02f);

            castTimeBeforeHaste -= 0.1f * druidTalents.Naturalist;

            critPercent += 2f * druidTalents.NaturesMajesty;

            //Living Seed, 30% seed, 33% * points spend (1/3)
            critModifier += 0.1f * druidTalents.LivingSeed;

            // 6% chance to get Omen of Clarity...
            manaCost *= 1 - 0.06f * druidTalents.OmenOfClarity;

            minHeal *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            maxHeal *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            coefDH *= (1 + 0.2f * druidTalents.EmpoweredTouch);

            coefDH *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);
        }
    }

    public class HealingTouchChain : HealingTouch
    {
        public HealingTouchChain(CharacterCalculationsTree calcs, Stats calculatedStats)
            : base(calcs, calculatedStats)
        {
            float d = 0.5f * critPercent * calculatedStats.SpellHasteFor5SecOnCrit_50;
            speed = (1 + (calculatedStats.HasteRating) / TreeConstants.HasteRatingToHaste);
            speed *= 1 + calculatedStats.SpellHaste + d;
            applyHaste();
        }
    }

    /*
     * Regrowth updated Jan 12th 2009 by Trolando
     * Using Resto Spreadsheet v1.21L, WoWHead.com, WoWWiki.com
     */
    public class Regrowth : Spell
    {
        public Regrowth(CharacterCalculationsTree calcs, Stats calculatedStats)
        {
            InitializeRegrowth(calcs, calculatedStats);
        }

        public Regrowth(CharacterCalculationsTree calcs, Stats calculatedStats, bool withRegrowthActive) 
        {
            InitializeRegrowth(calcs, calculatedStats);

            if (withRegrowthActive && calcs.LocalCharacter.DruidTalents.GlyphOfRegrowth) //(CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions).glyphOfRegrowth)
            {
                minHeal *= 1.2f;
                maxHeal *= 1.2f;
                periodicTick *= 1.2f;
                coefDH *= 1.2f;
                coefHoT *= 1.2f;
            }
        }

        private void InitializeRegrowth(CharacterCalculationsTree calcs, Stats calculatedStats)
        {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 2f;
            coefDH = 0.54f; 
            coefHoT = 1.316f / 7f;
            manaCost = 0.29f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;
            critPercent = calculatedStats.SpellCrit;

            minHeal = 2234;
            maxHeal = 2494;
            periodicTick = 335; // 2345 / 7
            periodicTicks = 7;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            #region Idols
            //z.B.: Idol of the Crescent Goddess (-65 Mana)
            manaCost -= calculatedStats.ReduceRegrowthCost;
            #endregion

            /* Glyph of Regrowth is modelled in the constructor */
            applyHaste();
        }

        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts)
        {
            periodicTicks += 2 * druidTalents.NaturesSplendor;

            manaCost -=
                manaCost * 0.03f * druidTalents.Moonglow +
                manaCost * 0.2f * druidTalents.TreeOfLife;

            critPercent += 5f * druidTalents.NaturesBounty;
            //Living Seed
            critModifier += 0.1f * druidTalents.LivingSeed;

            // 6% chance to get Omen of Clarity...
            manaCost *= 1 - 0.06f * druidTalents.OmenOfClarity;

            minHeal *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            maxHeal *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            coefDH *=
                (1 + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            periodicTick *=
                (1 + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            coefHoT *= 
                (1 + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1 + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);
        }
    }

    /*
     * Rejuvenation updated Jan 12th 2009 by Trolando
     * Using Resto Spreadsheet v1.21L, WoWHead.com, WoWWiki.com
     */
    public class Rejuvenation : Spell
    {
        public Rejuvenation(CharacterCalculationsTree calcs, Stats calculatedStats)
        {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 0f;
            coefHoT = 1.879f / 5;
            manaCost = 0.18f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;

            periodicTick = 338f; //1690 / 5 ... newest Rank got 15 seconds.. i hope it's not involed with another coef ..
            periodicTicks = 5;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            #region Idols etc
            //z.B.: Harold's Rejuvenating Broach 
            healingBonus += calculatedStats.RejuvenationSpellpower;
            //z.B.: Idol of Pure Thoughts
            periodicTick += calculatedStats.RejuvenationHealBonus;

            //z.B.: Idol of Budding Life (-36 Manacost)
            manaCost -= calculatedStats.ReduceRejuvenationCost;
            #endregion

            #region Tier 8 (4) SetBonus
            if (calculatedStats.RejuvenationInstantTick > 0.0f )
            {
                // Set AverageHealingwithCrit = PeriodicTick
                minHeal = PeriodicTick;
                maxHeal = PeriodicTick;
                coefDH = 0.0f;
                critPercent = 0.0f;
            }
            #endregion

            applyHaste();
        }

        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts)
        {
            periodicTicks += 1 * druidTalents.NaturesSplendor;

            //gcd *= 1 - 0.04f * druidTalents.GiftOfTheEarthmother;
            // use base gcd
            gcdBeforeHaste -= 1.5f * 0.04f * druidTalents.GiftOfTheEarthmother;

            manaCost *= 1 - 0.2f * druidTalents.TreeOfLife;

            // 6% chance to get Omen of Clarity...
            manaCost *= 1 - 0.06f * druidTalents.OmenOfClarity;

            periodicTick *=
                (1 + 0.01f * druidTalents.Genesis + 
                 0.05f * druidTalents.ImprovedRejuvenation + 
                 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            coefHoT *= 
                (1 + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1 + 0.01f * druidTalents.Genesis + 
                 0.05f * druidTalents.ImprovedRejuvenation + 
                 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);
        }
    }

    /*
     * Lifebloom updated Jan 12th 2009 by Trolando
     * Using Resto Spreadsheet v1.21L, WoWHead.com, WoWWiki.com
     */
    public class Lifebloom : Spell
    {
        protected float idolHoTBonus = 0f;
        protected float idolDHBonus = 0f;

        private float stackScaling = 1.0f;
        private float stackSize = 1.0f;

        protected float manaRefund = 0.0f;

        public override float PeriodicTick
        { get { return stackScaling * (periodicTick + (idolHoTBonus + healingBonus) * coefHoT); } }

        public override float AverageHealing
        {  get { return stackSize * (extraHealing + (minHeal + maxHeal) / 2 + HealingBonus * coefDH); } }


        public override float HealingBonus
        { 
            get { return healingBonus + idolDHBonus; }
            set { healingBonus = value; }
        }

        public override float ManaCost
        {
            get { return (base.ManaCost - manaRefund); }
            //            set { manaCost = value; }
        }

        public Lifebloom(CharacterCalculationsTree calcs, Stats calculatedStats)
        {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 0f;
            periodicTickTime = 1f;
            coefDH = 0.645f; 
            coefHoT = 0.6684f / 7f;
            manaCost = 0.28f * TreeConstants.BaseMana;      // manaCost without refund
            manaRefund = 0.14f * TreeConstants.BaseMana;    // 
            healingBonus = calculatedStats.SpellPower;
            critPercent = calculatedStats.SpellCrit;

            minHeal = 970f;
            maxHeal = 970f;
            periodicTick = 53f;
            periodicTicks = 7;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            #region Idols
            //z.B.: Idol of the Emerald Queen
            idolHoTBonus = calculatedStats.LifebloomTickHealBonus;

            //z.B.: Gladiator's Idol of Tenacity (87 on final heal), haven't one myself, will correct it when i've one
            idolDHBonus = calculatedStats.LifebloomFinalHealBonus;
            #endregion

            if (calcs.LocalCharacter.DruidTalents.GlyphOfLifebloom) //(calcOpts.glyphOfLifebloom)
                periodicTicks += 1;

            manaCost *= (1-calculatedStats.LifebloomCostReduction);

            applyHaste();
        }

        public Lifebloom(CharacterCalculationsTree calcs, Stats calculatedStats, int numStacks) : this(calcs, calculatedStats) 
        {
            if (numStacks == 1)
            {
                // Do nothing, already setup
            }
            else if (numStacks == 2)
            {
                float newPeriodicTicks = periodicTicks * 2 - 1;  // Double number of ticks, but lose 1
                manaCost *= 2;
                manaRefund *= 2;
                  // N-1 ticks of 1 stack + N ticks of 2 stacks, averaged over total ticks
                stackScaling = ( (periodicTicks-1)+2*periodicTicks ) / newPeriodicTicks;

                stackSize = 2.0f; // Bloom heal doubled

                periodicTicks = newPeriodicTicks;

                castTime = 2.0f * gcd;
            }
            else if (numStacks == 3)
            {
                float newPeriodicTicks = periodicTicks * 3 - 2;  // Triple number of ticks, but lose 1 each time
                manaCost *= 3;
                manaRefund *= 3;
                // N-1 ticks of 1 stack + N -1 ticks of 2 stacks, averaged over total ticks
                stackScaling = ( (periodicTicks - 1) + 2 * (periodicTicks - 1) + 3 * periodicTicks )/ newPeriodicTicks;

                stackSize *= 3.0f; // Bloom heal trippled

                periodicTicks = newPeriodicTicks;

                castTime = 3.0f * gcd;
            }
        }



        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts)
        {
            periodicTicks += 2 * druidTalents.NaturesSplendor;

            //gcd *= (1 - 0.04f * druidTalents.GiftOfTheEarthmother);
            // use base gcd
            gcdBeforeHaste -= 1.5f * 0.04f * druidTalents.GiftOfTheEarthmother;

            manaCost *= (1 - 0.2f * druidTalents.TreeOfLife);

            // 6% chance to get Omen of Clarity...
            manaCost *= 1 - 0.06f * druidTalents.OmenOfClarity;

            periodicTick *=
                (1 + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            coefHoT *= 
                (1 + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1 + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            minHeal *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            maxHeal *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            coefDH *=
                (1 + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter) *
                (1 + 0.06f * druidTalents.TreeOfLife);
        }
    }

    public class LifebloomStack : Lifebloom
    {
        public LifebloomStack(CharacterCalculationsTree calcs, Stats calculatedStats) : base(calcs, calculatedStats)
        {
            periodicTick *= 3;
            periodicTicks -= 1; // Keep a stack alive
            coefHoT *= 3;
            minHeal = 0f;
            maxHeal = 0f;
            coefDH = 0f;
            critPercent = 0f;

//            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;
//            if (calcOpts.newManaRegen) 
            manaRefund = 0;       // manaCost is now without refund   

        }
    }

    /*
     * Wild Growth updated Jan 12th 2009 by Trolando
     * Using Resto Spreadsheet v1.21L, WoWHead.com, WoWWiki.com
     */
    public class WildGrowth : Spell
    {
        float[][] tickRanks = new float[][]
        { 
             new float[] {176f, 157f, 140f, 123f, 105f, 88f, 70f}, //mostly observation
             //quessed..
             new float[] {295f, 263f, 234f, 206f, 176f, 147f, 117f} //Rank 4
        };

        public int maxTargets;

        /// <summary>
        /// returns the Tick of WG, Ranks: 0 = Rank 2, 1 = Rank 4, valid index - 0 to 6
        /// </summary>
        public float getTick(int rank, int index)
        { return healingBonus * coefHoT + tickRanks[rank][index];  }

        public WildGrowth(CharacterCalculationsTree calcs, Stats calculatedStats)
        {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 0f;
            coefHoT = 0.8057f / 7f; 
            manaCost = 0.23f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;

            periodicTick = 206f; // 1442 / 7
            periodicTicks = 7;
            periodicTickTime = 1f;
            maxTargets = 5;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            applyHaste();
        }

        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts)
        {
            //gcd *= (1 - 0.04f * druidTalents.GiftOfTheEarthmother);
            // use base gcd
            gcdBeforeHaste -= 1.5f * 0.04f * druidTalents.GiftOfTheEarthmother;

            manaCost *= (1 - 0.2f * druidTalents.TreeOfLife);

            // 6% chance to get Omen of Clarity...
            manaCost *= 1 - 0.06f * druidTalents.OmenOfClarity;

            // Glyph of Wild Growth
            if (druidTalents.GlyphOfWildGrowth)
              maxTargets += 1;

            coefHoT *=
                (1 + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.06f * druidTalents.TreeOfLife) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife);

            float basecoef = 
                (1 + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.06f * druidTalents.TreeOfLife) *
                (1 + 0.02f * druidTalents.MasterShapeshifter);

            periodicTick *= basecoef;
            for (int i = 0; i < 7; i++)
            { 
                tickRanks[0][i] *= basecoef;
                tickRanks[1][i] *= basecoef;
            }
        }
    }

    /*
     * Nourish updated Jan 12th 2009 by Trolando
     * Using Resto Spreadsheet v1.21L, WoWHead.com, WoWWiki.com
     */
    public class Nourish : Spell
    {
        float NourishBonusPerHoTGlyphs;

        public Nourish(CharacterCalculationsTree calcs, Stats calculatedStats)
        {
            InitializeNourish(calcs, calculatedStats);
        }

        public Nourish(CharacterCalculationsTree calcs, Stats calculatedStats, int hotsActive)
        {
            InitializeNourish(calcs, calculatedStats);
            if (hotsActive>0)
            {
                minHeal *= 1.2f + (calculatedStats.NourishBonusPerHoT + NourishBonusPerHoTGlyphs) * hotsActive;
                maxHeal *= 1.2f + (calculatedStats.NourishBonusPerHoT + NourishBonusPerHoTGlyphs) * hotsActive;
                coefDH  *= 1.2f + (calculatedStats.NourishBonusPerHoT + NourishBonusPerHoTGlyphs) * hotsActive;
            }
        }

        private void InitializeNourish(CharacterCalculationsTree calcs, Stats calculatedStats)
        {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 1.5f;
            coefDH = 0.6611f; // Spreadsheet says .69, wowwiki says .6611, 1.5/3.5 = .43, confused!
            manaCost = 0.18f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;
            critPercent = calculatedStats.SpellCrit;

            minHeal = 1883f;
            maxHeal = 2187f;
            NourishBonusPerHoTGlyphs = 0.0f;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            #region Idols
            // Idol of Flourishing Life
            healingBonus += calculatedStats.NourishSpellpower;
            #endregion

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            applyHaste();
        }

        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts)
        {
            manaCost *= (1 - druidTalents.TranquilSpirit * 0.02f);

			critPercent += 2f * druidTalents.NaturesMajesty;
            critPercent += 5f * druidTalents.NaturesBounty;

            //Living Seed, 30% seed, 33% * points spend (1/3)
            //if (calcOpts.useLivingSeedAsCritMultiplicator)
            critModifier += 0.1f * druidTalents.LivingSeed;

            // 6% chance to get Omen of Clarity...
            manaCost *= 1 - 0.06f * druidTalents.OmenOfClarity;
                
            minHeal *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            maxHeal *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            coefDH *=
                (1 + 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            if (druidTalents.GlyphOfNourish)
                NourishBonusPerHoTGlyphs = 0.06f;
        }
    }
}
