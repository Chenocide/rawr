using System;

namespace Rawr.Tree {

    public abstract class Spell {
        public string name = "Unknown";
        public virtual string Name { get { return name + (lbTarget ? " Tank" : alreadyHottedTarget? " HoT'd" : " Raid"); } }
        protected DruidTalents druidTalents;
        protected CalculationOptionsTree calcOpts;
        protected float minHeal             = 0f;
        public float    MinHeal     { get { return healModifier * (minHeal + spellPower * coefDH); } }
        public float    BaseMinHeal { get { return minHeal; } }

        protected float maxHeal             = 0f;
        public float    MaxHeal     { get { return healModifier * (maxHeal + spellPower * coefDH); } }
        public float    BaseMaxHeal { get { return maxHeal; } }

        // Used for lifebloom stacking, which takes a number of casts to get the full stack back up after it drops off
        protected int numberOfCasts = 1;    
        public float NumberOfCasts { get { return numberOfCasts; } }

        public float castTime = 0f;
        public float castTimeBeforeHaste = 0f;
        public float CastTime { 
            get {
                if (castTime > gcd) { return numberOfCasts * castTime;
                } else if (gcd > 1) { return numberOfCasts * gcd;
                } else {              return numberOfCasts; }
            }
        }
        public float gcd            = 1.5f;
        public float gcdBeforeHaste = 1.5f;

        protected float manaCost    = 0f;
        protected float manaCostModifier = 1f;
        virtual public float ManaCost { get { return ManaCostTrue - ManaRevitalize; } }
        virtual public float ManaCostTrue { get { return manaCost * manaCostModifier * numberOfCasts; } }

        protected float manaRevitalize = 0f;
        virtual public float ManaRevitalize { get { return manaRevitalize * PeriodicTicks; } }

        public float coefDH  = 0f; //coef for DirectHeal
        public float coefHoT = 0f; //coef for HoT
        protected float spellPower = 0f;
        public float SpellPower { get { return spellPower; } }
        public float speed = 1f;
        protected float critModifier = 1.5f;
        public float CritModifier { get { return critModifier; } }
        protected float critRatio = 0f;
        public float CritRatio { get { return critRatio; } }
        protected float critHoTRatio = 0f;
        public float CritHoTRatio { get { return critHoTRatio; } }
        protected float periodicTick = 0f;
        protected float periodicTicks = 0f;
        protected float periodicTicksBeforeHaste = 0f;
        public float PeriodicTicks { get { return periodicTicks; } }
        protected float periodicTickTimeBeforeHaste = 3f; // this is only for rejuvenation at the moment
        protected float periodicTickTime = 3f;
        public float PeriodicTickTime { get { return periodicTickTime; } }

        protected float extraHealing = 0f; // for BonusHoTOnDirectHeals
        protected float healModifier = 1f; // for BonusHealingDoneMultiplier
        protected float periodicModifier = 1f;

        protected bool alreadyHottedTarget = false;
        protected bool lbTarget = false;
        public void SetLBTarget() { lbTarget = true; alreadyHottedTarget = true; }

        protected float cooldown = 0f;
        /// <summary>
        /// Max possible cast time
        /// </summary>
        public float MaxCastFraction { get { return CastTime / (CastTime + cooldown); } }
        /// <summary>
        ///  Max cast time without clipping
        /// </summary>
        public float MaxUsableCastFraction { get { return Math.Min(CastTime / Duration, MaxCastFraction); } }   

        virtual public float AverageHealing { get { return healModifier * (extraHealing + (minHeal + maxHeal) / 2f + SpellPower * coefDH); } }

        /// <summary>
        ///  Direct heal component of this spell
        /// </summary>
        public float AverageHealingwithCrit { get { return (AverageHealing * (1.0f - CritRatio) + (AverageHealing * CritModifier) * CritRatio) ; } }

        virtual public float PeriodicTick { get { return healModifier * (periodicTick + spellPower * coefHoT) * periodicModifier; } }

        virtual public float PeriodicTickwithCrit { get { return (PeriodicTick * (1.0f - critHoTRatio) + (PeriodicTick * CritModifier) * critHoTRatio) ; } }

        /// <summary>
        /// Total healing generated by this spell, includes base, crit and HoT effects 
        /// </summary>
        public float TotalAverageHealing { get { return (AverageHealingwithCrit + PeriodicTickwithCrit * PeriodicTicks); } }

        public float Duration { get { return periodicTicks * periodicTickTime; } }

        // HPS: The healing per second you will get when either chaincasting or refreshing perfectly
        // HPS_DH: Direct Healing divided per cast time
        //         If you want to know the chaincast healing, use HPCT_DH
        // HPS_HOT: Rate at which HoT healing is applied
        //          Different from the rate at which it can be generated by the druid (see HPCT)
        public float HPS { get { return TotalAverageHealing / Math.Max(CastTime+cooldown, Duration); } }
        public float HPS_DH { get { return AverageHealingwithCrit / Math.Max(CastTime + cooldown, Duration); } }
        public float HPS_HOT { get { return periodicTickTime > 0 ? PeriodicTickwithCrit / periodicTickTime : 0; } }

        public float HPM { get { return TotalAverageHealing / ManaCost; } }
        public float HPM_DH { get { return AverageHealingwithCrit / ManaCost; } }
        public float HPM_HOT { get { return PeriodicTickwithCrit * PeriodicTicks / ManaCost; } }

        // Wildebees: 20090221 : Healing per cast time, considers direct healing and HoT parts
        //     Total healing divided by CastTime
        // This indicates the rate at which the healing is generated
        public float HPCT { get { return TotalAverageHealing / CastTime; } }
        public float HPCT_DH { get { return AverageHealingwithCrit / CastTime; } }
        public float HPCT_HOT { get { return PeriodicTickwithCrit * PeriodicTicks / CastTime; } }

        public float HPSPM { get { return HPS / ManaCost; } }
        public float HPSPM_DH { get { return HPS_DH / ManaCost; } }
        public float HPSPM_HOT { get { return HPS_HOT / ManaCost; } }

        public float HPCTPM { get { return HPCT / ManaCost; } }
        public float HPCTPM_DH { get { return HPCT_DH / ManaCost; } }
        public float HPCTPM_HOT { get { return HPCT_HOT / ManaCost; } }

        public float NumHeals { get { return PeriodicTicks + (AverageHealing > 0f ? 1f : 0f); } }  // If we have a direct heal + num periodicTicks
        public float NumExpectedCrits { get { return PeriodicTicks*CritHoTRatio + (AverageHealing > 0f ? 1.0f : 0f) * CritRatio; } }  // Weight number of heals by crit rates

        public float bonusLifeBloomRefresh = 0f;
        public float BonusLifeBloomRefresh { get { return lbTarget ? bonusLifeBloomRefresh : 0; } }

        public float omenProcs = 0f;
        public float OmenProcs { get { return omenProcs; } }

        protected float castFraction = 0f;
        public float CastFraction { get { return castFraction; } set { castFraction = value; } }
        public float CastsPerMinute { set { castFraction = value * CastTime / 60.0f; } get { return castFraction / CastTime * 60f; } }


        public virtual void applyStats(Stats stats)
        {
            speed = (1 + StatConversion.GetSpellHasteFromRating(stats.HasteRating)) * (1 + stats.SpellHaste);
            critModifier = 1.5f * (1f + stats.BonusCritHealMultiplier);
            healModifier =  (1.0f + TreeConstants.GiftOfNature) *
                            (1f + stats.BonusHealingDoneMultiplier) * 
                            (1f + 0.04f * druidTalents.MasterShapeshifter) *
                            (1f + 0.15f * druidTalents.TreeOfLife * (25.0f + 3.0f * druidTalents.NaturalShapeshifter) / 180.0f) *
                            (1.0f + (alreadyHottedTarget ? +TreeConstants.Symbiosis(stats) : 0f)) ;
            extraHealing = stats.BonusHealingReceived;
            applyHaste();
            applyHasteToPeriodicTickTime();

            omenProcs = (druidTalents.MalfurionsGift > 0) ? 0.06f : 0f;  // Assume all heal spells can trigger Omen
            periodicModifier = (1f + druidTalents.Genesis * 0.02f);
            manaCostModifier = (1 - 0.03f * druidTalents.Moonglow);
            // 6% chance to get Omen of Clarity...
            //manaCostModifier *= 1f - 0.06f * druidTalents.OmenOfClarity;

            spellPower = stats.SpellPower;
            critRatio = stats.SpellCrit;
            critHoTRatio = stats.SpellCrit;
            manaCost -= stats.SpellsManaReduction;
            manaCost -= stats.NatureSpellsManaReduction;

        }
        
        protected virtual void applyHaste() {
            gcd = gcdBeforeHaste / speed;
            if (gcd < 1f) { gcd = 1f; }
            castTime = (float)Math.Round(castTimeBeforeHaste / speed, 4);
        }

        protected virtual void applyHasteToPeriodicTickTime() {
            // Does Nature's Grace affect the duration of Rejuvenate?
            // It says: "casting speed" so I expect not...
            periodicTickTime = periodicTickTimeBeforeHaste / speed;

            periodicTicks = (float)Math.Round(periodicTicksBeforeHaste * periodicTickTimeBeforeHaste / periodicTickTime);  // calculate number of hastened ticks

        }

        public override string ToString()
        {
            return ""+Math.Round(AverageHealingwithCrit, 0) + "*" + Math.Round(MinHeal, 0) + " - " + Math.Round(MaxHeal, 0) + " normal\n" + Math.Round(MinHeal * CritModifier, 0) + " - " + Math.Round(MaxHeal * CritModifier, 0) + " crit\n" + Math.Round(CritRatio*100.0f, 2) + "% crit chance\n" + (PeriodicTick>0?Math.Round(PeriodicTick, 0)+" every "+Math.Round(PeriodicTickTime, 2)+" s.":"");
        }

        public string TickToString()
        {
            return "" + Math.Round(PeriodicTickwithCrit, 0) + "*" + Math.Round(PeriodicTick, 0) + " normal\n" + Math.Round(PeriodicTick * CritModifier, 0) + " crit\n" + Math.Round(CritHoTRatio * 100.0f, 2) + "% crit chance\n" + Math.Round(PeriodicTicks, 0) + " ticks every " + Math.Round(PeriodicTickTime, 2) + " s." ;
        }

        public string HPMToString()
        {
            return "" + Math.Round(HPM, 2) + "*" + Math.Round(TotalAverageHealing, 0) + " healed\n" + Math.Round(ManaCost, 0) + " mana\n";
        }

        public Spell(Character character, Stats calculatedStats)
        {
            calcOpts = (CalculationOptionsTree)character.CalculationOptions;
            druidTalents = character.DruidTalents;
        }

    }
    public class HealingTouch : Spell {
        protected float extraCritModifier = 0f;
        public HealingTouch(Character character, Stats calculatedStats, bool hotsActive = false)
            : base(character, calculatedStats)
        {
            name = "HT";
            alreadyHottedTarget = hotsActive;


            #region Base Values
            castTimeBeforeHaste = 3f;
            coefDH = 0.806f;
            minHeal = 7211f;
            maxHeal = 8515f;
            manaCost = 0.30f * TreeConstants.BaseMana;
            #endregion

            calculateTalents(character.DruidTalents, calcOpts);

            #region Glyph of Healing Touch
            if (character.DruidTalents.GlyphOfHealingTouch) {
            }
            #endregion

            applyStats(calculatedStats);
        }
        public override void applyStats(Stats stats)
        {
            base.applyStats(stats);
            critModifier += extraCritModifier;
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {

            castTimeBeforeHaste -= (druidTalents.Naturalist > 1) ? 0.5f : 0.2f * druidTalents.Naturalist; 


            //Living Seed, 30% seed, 33% * points spend (1/3)
            extraCritModifier = 0.1f * druidTalents.LivingSeed * calcOpts.Current.LivingSeedEfficiency / 100f;

            coefDH *= (1.0f + 0.05f * druidTalents.EmpoweredTouch);
            minHeal *= (1.0f + 0.05f * druidTalents.EmpoweredTouch);
            maxHeal *= (1.0f + 0.05f * druidTalents.EmpoweredTouch);

            bonusLifeBloomRefresh += 0.50f * druidTalents.EmpoweredTouch;


        }
    }
    public class Regrowth : Spell {
        protected float extraCrit = 0f;
        protected float extraCritModifier = 0f;
        public Regrowth(Character character, Stats stats, bool allowHoT, bool hotsActive = false)
            : base(character, stats)
        {
            name = "RG";
            alreadyHottedTarget = hotsActive;

            InitializeRegrowth(character, stats, allowHoT); 
        }
        private void InitializeRegrowth(Character character, Stats stats, bool allowHoT) {

            #region Base Values
            castTimeBeforeHaste = 1.5f;
            coefDH = 0.54f;
            coefHoT = 0.2936f; // 1.316f / 7f;

            minHeal = 3383f;
            maxHeal = 3775f;
            periodicTick = 361f; 
            periodicTicksBeforeHaste = 3f;
            periodicTickTimeBeforeHaste = 2f;
            manaCost = 0.35f * TreeConstants.BaseMana;

            if (!allowHoT)
            {
                periodicTick = 0f;
                periodicTicksBeforeHaste = 0f;
                periodicTickTimeBeforeHaste = 3f;
                coefHoT = 0f;
                name = "RGSpam";
            }
            #endregion

            // Seems to apply before talents

            calculateTalents(character.DruidTalents, calcOpts);

            applyStats(stats);
        }
        public override void applyStats(Stats stats)
        {
            base.applyStats(stats);
            critRatio += extraCrit;
            critHoTRatio += extraCrit;
            critModifier += extraCritModifier;
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {
            //periodicTicks += 2 * druidTalents.NaturesSplendor;
            
            extraCrit += 0.20f * druidTalents.NaturesBounty;

            //Living Seed
            extraCritModifier = 0.1f * druidTalents.LivingSeed * calcOpts.Current.LivingSeedEfficiency / 100f;


        }
    }
    public class Rejuvenation : Spell {
        private float extraTicks = 0f;
        private float periodicTickModifier = 1f;
        public Rejuvenation(Character character, Stats calculatedStats, bool hotsActive = false)
            : base(character, calculatedStats)
        {
            name = "RJ";
            alreadyHottedTarget = hotsActive;

            #region Base Values
            castTimeBeforeHaste = 0f;
            coefHoT = 0.134f;
            periodicTicksBeforeHaste = 4f;
            periodicTickTimeBeforeHaste = 3f;
            manaCost = 0.25f * TreeConstants.BaseMana;
            periodicTick = 1307f; //  / 4.0f;
            #endregion

            calculateTalents(character.DruidTalents, calcOpts);

            applyStats(calculatedStats);
        }
        public override void applyStats(Stats stats)
        {
            base.applyStats(stats);

            healModifier *= 1.0f + ((druidTalents.GlyphOfRejuvination) ? 0.1f : 0.0f);

            periodicTick *= periodicTickModifier; // from talents

            #region Tier 8 (4) SetBonus
            if (stats.RejuvenationInstantTick > 0.0f)
            {
                // Set AverageHealingwithCrit = PeriodicTick
                //Some talents doesn't apply to this instant tick, so it should actually be less than the normal tick, hopefully small enough error
                minHeal += PeriodicTick * stats.RejuvenationInstantTick;
                maxHeal += PeriodicTick * stats.RejuvenationInstantTick;
                coefDH = 0.0f; // PeriodicTick already scaled by SpellPower, so don't scale again
            }
            #endregion 

            #region Tier 10 (4) SetBonus
            if (stats.RejuvJumpChance > 0)
            {
                // chanceOncePerRejuv = (float)(1f - Math.Pow(1f - calculatedStats.RejuvJumpChance, periodicTicks));
                float chance = periodicTicks * stats.RejuvJumpChance;
                float factor = 1f; // assume it doesn't consume existing buff, if it does then factor = 0.5f
                // assume it will jump multiple times
                periodicTicks *= (1f + factor * chance + factor * chance * chance + factor * chance * chance * chance);
                //only one jump: periodicTicks *= (1f + factor * chance);
            }
            #endregion

            
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {
            //extraTicks += 1 * druidTalents.NaturesSplendor;

            periodicTickModifier *=
                (1  + 0.05f * druidTalents.ImprovedRejuvenation) * (druidTalents.GlyphOfRejuvination ? 1.0f : 1.1f ) * (1f + 0.02f * druidTalents.BlessingOfTheGrove);

            coefHoT *= 
                //(1 + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1 + 0.05f * druidTalents.ImprovedRejuvenation) * (druidTalents.GlyphOfRejuvination ? 1.0f : 1.1f) * (1f + 0.02f * druidTalents.BlessingOfTheGrove);

            manaRevitalize = druidTalents.Revitalize * 0.08f * 0.03f * TreeConstants.BaseMana;

            minHeal = 0.05f * druidTalents.GiftOfTheEarthmother * PeriodicTick * periodicTicksBeforeHaste;  // Assume the instant cast effect is determined before haste scales number of ticks
            maxHeal = 0.05f * druidTalents.GiftOfTheEarthmother * PeriodicTick * periodicTicksBeforeHaste;  // Assume the instant cast effect is determined before haste scales number of ticks
            coefDH = 0.0f; // PeriodicTick already scaled by SpellPower, so don't scale again

            gcdBeforeHaste -= (druidTalents.SwiftRejuvenation> 1) ? 0.5f : 0.2f * druidTalents.SwiftRejuvenation;

        }
    }
    public class Lifebloom : Spell {
        public override string Name { get { return name; } }
        protected float extraCrit = 0f;
        protected float stackScaling = 1.0f;
        protected float stackSize = 1.0f;
        public override float PeriodicTick { get { return stackScaling * base.PeriodicTick; } }
        public override float AverageHealing {  get { return stackSize * base.AverageHealing; } }
        public Lifebloom(Character character, Stats stats)
            : base(character, stats)
        {
            name = "LB";

            #region Base Values
            castTimeBeforeHaste = 0f;
            periodicTickTimeBeforeHaste    = 1f;
            coefHoT = 0.0234f; 

            minHeal = 2306f;
            maxHeal = 2306f;
            coefDH = 0.355f; 

            periodicTick = 228f;
            periodicTicksBeforeHaste = 10f;
            manaCost = 0.07f * TreeConstants.BaseMana;
            #endregion

            // Seems to apply before talents

            calculateTalents(character.DruidTalents, calcOpts);

            applyStats(stats);
            omenProcs = PeriodicTicks * character.DruidTalents.MalfurionsGift * 0.02f; 
        }

        public Lifebloom(Character character, Stats stats, int numStacks, bool fastStack)
            : this(character, stats)
        {
            float newPeriodicTicks = periodicTicks;

            if (numStacks == 1) {
                // Do nothing, already setup
            } else if (numStacks == 2) {
                if (!fastStack) {
                    #region Slow LB stacking
                    newPeriodicTicks = periodicTicks * 2 - 1;  // Double number of ticks, but lose 1
                    // N-1 ticks of 1 stack + N ticks of 2 stacks, averaged over total ticks
                    stackScaling = ((periodicTicks - 1) + 2 * periodicTicks) / newPeriodicTicks;
                    name = "LB2s";
                    #endregion
                } else {
                    #region Fast LB stacking
                    newPeriodicTicks = periodicTicks + 1;  // Stack every tick 
                    // 1 ticks of 1 stack + N ticks of 2 stacks, averaged over total ticks
                    stackScaling = ((1) + 2 * periodicTicks) / newPeriodicTicks;
                    name = "LB2f";
                    #endregion
                }

                stackSize = 2.0f; // Bloom heal doubled

                periodicTicks = newPeriodicTicks;
                numberOfCasts = 2;
            } else if (numStacks == 3) {
                if (!fastStack) {
                    #region Slow LB stacking
                    newPeriodicTicks = periodicTicks * 3 - 2;  // Triple number of ticks, but lose 1 each time
                    // N-1 ticks of 1 stack + N -1 ticks of 2 stacks, averaged over total ticks
                    stackScaling = ((periodicTicks - 1) + 2 * (periodicTicks - 1) + 3 * periodicTicks) / newPeriodicTicks;
                    name = "LB3s";
                    #endregion
                } else {
                    #region Fast LB stacking
                    newPeriodicTicks = periodicTicks + 2;  // Stack every tick 
                    // 1 ticks of 1 stack + 1 ticks of 2 stacks, averaged over total ticks
                    stackScaling = ((1) + 2 * (1) + 3 * periodicTicks) / newPeriodicTicks;
                    name = "LB3f";
                    #endregion
                }

                stackSize *= 3.0f; // Bloom heal trippled

                periodicTicks = newPeriodicTicks;

                numberOfCasts = 3;
            }

            calculateTalents(character.DruidTalents, calcOpts);

            applyStats(stats);
            omenProcs = PeriodicTicks * character.DruidTalents.MalfurionsGift * 0.02f; 

        }
        public override void applyStats(Stats stats)
        {
            base.applyStats(stats);
            manaCost *= numberOfCasts;
            critRatio += extraCrit;
            critHoTRatio += extraCrit; 

        }
        protected void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {

            minHeal *= 1.0f + 0.05f * druidTalents.GiftOfTheEarthmother;
            maxHeal *= 1.0f + 0.05f * druidTalents.GiftOfTheEarthmother;
            coefDH *= 1.0f + 0.05f * druidTalents.GiftOfTheEarthmother;

            if (druidTalents.GlyphOfLifebloom) 
            {
                extraCrit += 0.10f;
            } //(calcOpts.glyphOfLifebloom)

            manaRevitalize = druidTalents.Revitalize * 0.08f * 0.03f * TreeConstants.BaseMana;


        }
    }
    public class LifebloomStack : Lifebloom {
        public LifebloomStack(Character character, Stats stats)
            : base(character, stats)
        {
            periodicTick  *= 3f;
            periodicTicks -= 1f; // Keep a stack alive
            coefHoT       *= 3f;
            minHeal        = 0f;
            maxHeal        = 0f;
            coefDH         = 0f;
            name = "LBS";

            base.calculateTalents(character.DruidTalents, calcOpts);

            applyStats(stats);
            omenProcs = PeriodicTicks * character.DruidTalents.MalfurionsGift * 0.02f; 

        }
    }
    public class WildGrowth : Spell {
        public int maxTargets;
        private float periodickTickModifier = 1f;
        private float[] baseTick = new float[7];
        private float[] tick = new float[7];
        public float[] BaseTick { get { return tick; } }
        public float[] Tick { get { return tick; } }
        public WildGrowth(Character character, Stats stats)
            : base(character, stats)
        {
            name = "WG";

            #region Base Values
            cooldown = 10f;
            castTimeBeforeHaste = 0f;
            coefHoT = 0.042f;

            periodicTick = 2863 / 7f;   
            periodicTicksBeforeHaste = 7f;
            periodicTickTimeBeforeHaste =   1f;
            maxTargets       =   5;
            manaCost = 0.27f * TreeConstants.BaseMana;
            #endregion

            calculateTalents(character.DruidTalents, calcOpts);

            applyStats(stats);
        }
        public override void applyStats(Stats stats)
        {
            base.applyStats(stats);

            #region T10 (2) SetBonus
            float healing = 0f;
            for (int i = 0; i < 7; i++)
            {
                baseTick[i] = 293f - 29f * (1f - stats.WildGrowthLessReduction) * i;
                tick[i] = baseTick[i] + coefHoT * spellPower;
                healing += baseTick[i];
            }
            periodicTick = healing / 7;
            #endregion
            periodicTick *= periodickTickModifier;
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {

            periodicTick *= druidTalents.WildGrowth;

            // Glyph of Wild Growth
            if (druidTalents.GlyphOfWildGrowth)
              maxTargets += 1;


         }
    }
    public class Nourish : Spell {
        private float NourishBonusPerHoTGlyphs;
        protected float extraCritModifier = 0f;
        public Nourish(Character character, Stats stats) : base(character, stats) { InitializeNourish(character, stats); }
        public Nourish(Character character, Stats stats, bool hotsActive = false)
            : base(character, stats)
        {
            alreadyHottedTarget = hotsActive;

            name = "N";
            InitializeNourish(character, stats);
            if (hotsActive) {
                minHeal *= 1.2f + (stats.NourishBonusPerHoT + NourishBonusPerHoTGlyphs); // *hotsActive;
                maxHeal *= 1.2f + (stats.NourishBonusPerHoT + NourishBonusPerHoTGlyphs); // *hotsActive;
                coefDH *= 1.2f + (stats.NourishBonusPerHoT + NourishBonusPerHoTGlyphs);  // *hotsActive;
            }
        }
        private void InitializeNourish(Character character, Stats stats)
        {

            #region Base Values
            castTimeBeforeHaste = 3f;
            coefDH = 0.266f; // 

            minHeal = 2403f;
            maxHeal = 2791f;
            NourishBonusPerHoTGlyphs = 0.0f;
            manaCost = 0.10f * TreeConstants.BaseMana;
            #endregion

            calculateTalents(character.DruidTalents, calcOpts);

            applyStats(stats);
        }
        public override void applyStats(Stats stats)
        {
            base.applyStats(stats);
            #region Tier 9 2 piece Set Bonus
            critRatio += (stats.NourishCritBonus); 
            #endregion
            critModifier += extraCritModifier;
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {

            castTimeBeforeHaste -= (druidTalents.Naturalist > 1) ? 0.5f : 0.2f * druidTalents.Naturalist;


            //Living Seed, 30% seed, 33% * points spend (1/3)
            //if (calcOpts.useLivingSeedAsCritMultiplicator)
            extraCritModifier += 0.1f * druidTalents.LivingSeed * calcOpts.Current.LivingSeedEfficiency / 100f;

            coefDH *= (1.0f + 0.05f * druidTalents.EmpoweredTouch);
            minHeal *= (1.0f + 0.05f * druidTalents.EmpoweredTouch);
            maxHeal *= (1.0f + 0.05f * druidTalents.EmpoweredTouch);

            bonusLifeBloomRefresh += 0.50f * druidTalents.EmpoweredTouch;

            //if (druidTalents.GlyphOfNourish) { NourishBonusPerHoTGlyphs = 0.06f; }
        }
    }
    public class Swiftmend : Spell {
        public float regrowthUseChance = 0.0f;
        public float rejuvUseChance = 0.0f;
        public float regrowthTicksLost = 0.0f;
        public float rejuvTicksLost = 0.0f;
        protected float extraCritModifier = 0f;
        public override String ToString() {  return base.ToString() + "\n Excluding Efflorescence " ; } 
        public Swiftmend(Character character, Stats stats, Spell Rejuv)
            : base(character, stats)
        {
            alreadyHottedTarget = true;

            name = "SM";
            regrowthUseChance = rejuvUseChance = regrowthTicksLost = rejuvTicksLost = 0.0f;

            if (!character.DruidTalents.GlyphOfSwiftmend)
            {
                rejuvTicksLost = 2.0f;      // If cast randomly, consume half of the ticks, doesn't model haste increased number of ticks
            }

            #region Base Values
            cooldown = 15f;
            castTimeBeforeHaste = 0;
            manaCost = 0.10f * TreeConstants.BaseMana;

            minHeal = 5229f;
            maxHeal = 5229f;
            coefDH = 0.536f;
            #endregion

            /*if (character.DruidTalents.Swiftmend == 0)
            {
                Rejuv = null;
                Regrowth = null;
            }

            if (Rejuv == null) {
                if (Regrowth == null) {
                    // No HoTs, so Swiftmend not possible
                }else{
                    // Case of only Regrowth
                    minHeal = 5229f;
                    maxHeal = 5229f;
                    coefDH = 0.536f;
                    regrowthUseChance = 1.0f;
                    if (!character.DruidTalents.GlyphOfSwiftmend)
                    {
                        regrowthTicksLost = (Regrowth.PeriodicTicks + 1f) / 2.0f;      // If cast randomly, consume half of the ticks
                    }
                }
            }else if (Regrowth == null){
                // Case of only Rejuv
                minHeal = 5229f;
                maxHeal = 5229f;
                coefDH = 0.536f;
                rejuvUseChance = 1f;
                if (!character.DruidTalents.GlyphOfSwiftmend)
                {
                    rejuvTicksLost = (Rejuv.PeriodicTicks + 1f)/ 2.0f;      // If cast randomly, consume half of the ticks
                }
            }else{
                // Case of both active

                //TODO: Find a formula to calculate this, instead of assuming fixed percentage
                float selectedRejuv,selectedRegrowth,lostRejuvTicks,lostRegrowthTicks = 0;

                lostRejuvTicks = Rejuv.PeriodicTicks / 2f;
                selectedRejuv = 0.25f;                               // Just because, no proper reason
                lostRegrowthTicks = Rejuv.PeriodicTicks/ 2f;
                selectedRegrowth = 1f - selectedRejuv;

                minHeal = 5229f;
                maxHeal = minHeal;
                coefDH = 0.536f;

                if (!character.DruidTalents.GlyphOfSwiftmend)
                {
                    rejuvTicksLost = lostRejuvTicks / selectedRejuv;
                    regrowthTicksLost = lostRegrowthTicks / selectedRegrowth;
                }
            }
             */ 
            #region Nightsong (Tier 8) 2 item set bonus
            minHeal *= (1.0f + stats.SwiftmendBonus);
            maxHeal *= (1.0f + stats.SwiftmendBonus);
            #endregion

            spellPower = stats.SpellPower;
            calculateTalents(character.DruidTalents, calcOpts);
            applyStats(stats);
            applyHaste();
        }
        public override void applyStats(Stats stats)
        {
            base.applyStats(stats);
            critModifier += extraCritModifier;

        }

        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts)
        {
            //Living Seed, 30% seed, 33% * points spend (1/3)
            //if (calcOpts.useLivingSeedAsCritMultiplicator)
            extraCritModifier += 0.1f * druidTalents.LivingSeed * calcOpts.Current.LivingSeedEfficiency / 100f;

            minHeal *=
                //(1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.04f * druidTalents.MasterShapeshifter) * (1f + 0.05f * druidTalents.ImprovedRejuvenation) * (1f + druidTalents.Genesis * 0.02f);

            maxHeal *=
                //(1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.04f * druidTalents.MasterShapeshifter) * (1f + 0.05f * druidTalents.ImprovedRejuvenation) * (1f + druidTalents.Genesis * 0.02f);


            coefDH *=
                //(1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.04f * druidTalents.MasterShapeshifter) * (1f + 0.05f * druidTalents.ImprovedRejuvenation) * (1f + druidTalents.Genesis * 0.02f);


          

        }
    }

    public class Efflorescence : Spell
    {
        private Swiftmend SM = null;
        protected float numMelee = 3;
        protected float beforeEfflorescence = 0f;


        public Efflorescence(Character character, Stats stats, Spell Rejuv, int _numMelee)
            : base(character, stats) 
        {
            SM = new Swiftmend(character, stats, Rejuv);
            alreadyHottedTarget = true;

            name = "EF";

            numMelee = _numMelee;

            minHeal = SM.MinHeal * druidTalents.Efflorescence * 0.1f;     // Wowpedia lists it as 20% ? 
            maxHeal = SM.MaxHeal * druidTalents.Efflorescence * 0.1f;
            coefDH  = SM.coefDH * druidTalents.Efflorescence * 0.1f;
            critRatio = SM.CritRatio;
            manaCost = 1;   // Placeholder in order to not get divide by 0
            castTime = 0.1f; // Placeholder in order to not get divide by 0

       

        }
    }
}



