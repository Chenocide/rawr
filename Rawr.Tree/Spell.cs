using System;

namespace Rawr.Tree {
    public abstract class Spell {
        protected float minHeal             = 0f;
        public float    MinHeal     { get { return minHeal + healingBonus * coefDH; } }
        public float    BaseMinHeal { get { return minHeal; } }
        protected float maxHeal             = 0f;
        public float    MaxHeal     { get { return maxHeal + healingBonus * coefDH; } }
        public float    BaseMaxHeal { get { return maxHeal; } }
        public float    castTime            = 0f;
        public float    castTimeBeforeHaste = 0f;
        public float CastTime { 
            get {
                if (castTime > gcd) { return castTime; // Not castTimeBeforeHaste
                } else if (gcd > 1) { return gcd;
                } else {              return 1f; }
            }
        }
        public float gcd            = 1.5f;
        public float gcdBeforeHaste = 1.5f;
        protected float manaCost    = 0f;

        virtual public float ManaCost { get { return checkOmenlikeProcs(); } /*set { manaCost = value; }*/ }

        public float coefDH  = 0f; //coef for DirectHeal
        public float speed   = 1f;
        public float NGspeed = 1f;
        public float NGmod   = 0f;
        protected float healingBonus = 0f;
        virtual public float HealingBonus {
            get { return healingBonus; }
            set { healingBonus = value; }
        }
        protected float critModifier = 1.5f;
        public float CritModifier {
            get { return critModifier; }
            set { critModifier = value; }
        }
        protected float critPercent = 0f;
        public float CritPercent {
            get { return critPercent; }
            set { critPercent = value; }
        }
        protected float critHoTPercent = 0f;
        public float CritHoTPercent {
            get { return critHoTPercent; }
            set { critHoTPercent = value; }
        }
        protected float periodicTick = 0f;
        protected float periodicTicks = 0f;
        public float PeriodicTicks { get { return periodicTicks; } }
        protected float periodicTickTimeBeforeHaste = 3f; // this is only for rejuvenation at the moment
        protected float periodicTickTime = 3f;
        public float PeriodicTickTime { get { return periodicTickTime; } }
        public float coefHoT = 0f; //coef for HoT

        protected float extraHealing = 0f; // for BonusHoTOnDirectHeals
        
        virtual public float AverageHealing { get { return extraHealing + (minHeal + maxHeal) / 2f + HealingBonus * coefDH; } }

        /// <summary>
        ///  Direct heal component of this spell
        /// </summary>
        public float AverageHealingwithCrit { get { return (AverageHealing * (100f - critPercent) + (AverageHealing * critModifier) * critPercent) / 100f; } }

        virtual public float PeriodicTick { get { return periodicTick + healingBonus * coefHoT; } }

        virtual public float PeriodicTickwithCrit { get { return (PeriodicTick * (100f - critHoTPercent) + (PeriodicTick * critModifier) * critHoTPercent) / 100f; } }

        // Direct Healing divided per cast time
        virtual public float HPS { get { return AverageHealingwithCrit / CastTime; } }

        // Rate at which HoT healing is applied
        // Different from the rate at which it can be generated by the druid (see HPCT)
        public float HPSHoT { get { return (PeriodicTickwithCrit) / periodicTickTime; } }

        /// <summary>
        /// Total healing generated by this spell, includes base, crit and HoT effects 
        /// </summary>
        public float TotalAverageHealing { get { return (AverageHealingwithCrit + PeriodicTickwithCrit * PeriodicTicks); } }

        public float HPM { get { return (TotalAverageHealing) / ManaCost; } }

        // Wildebees: 20090221 : Healing per cast time, considers direct healing and HoT parts
        //     Total healing divided by CastTime
        // This indicates the rate at which the healing is generated
        public float HPCT { get { return (TotalAverageHealing) / CastTime; } }

        public float Duration { get { return periodicTicks * periodicTickTime; } }

        private Stats cachedStats;  // Keep a local copy of stats used to create spell

        public void Initialize(CharacterCalculationsTree calcs, Stats calculatedStats) {
            speed = (1 + StatConversion.GetSpellHasteFromRating(calculatedStats.HasteRating) );
            speed *= (1 + calculatedStats.SpellHaste);
            critModifier *= 1f + calculatedStats.BonusCritHealMultiplier;
            NGmod = calcs.LocalCharacter.DruidTalents.NaturesGrace / 3f;
            extraHealing = calculatedStats.BonusHealingReceived;
            cachedStats = calculatedStats;
            applyHaste();
        }

        public virtual void calculateOldNaturesGrace(float critChance) {
            if (castTimeBeforeHaste > 0) {
                castTimeBeforeHaste -= NGmod * critChance * 0.5f;
                applyHaste();
            }
        }

        public virtual void calculateNewNaturesGrace(float critChance) {
            if (castTimeBeforeHaste > 0) {
                applyHaste(); // calculate cast time
                /**
                 * Actually, if you have low primary heal usage, this will be a lot less!
                 * But! Often, primary heal usage is bursty in nature.
                 * spellsAffected = (int)(3f / castTime)
                 */
                float pNoBuff = 1f;
                for (int k = 0; k < 3f / castTime; k++) {
                    pNoBuff *= 1 - NGmod * critChance;
                }
                NGspeed = ( (1 - pNoBuff) * 0.2f) + 1f;
                applyHaste();
            }
        }
        
        protected virtual void applyHaste() {
            gcd = gcdBeforeHaste / (speed * NGspeed);
            if (gcd < 1f) { gcd = 1f; }
            castTime = (float)Math.Round(castTimeBeforeHaste / (speed * NGspeed), 4);
            if (castTime < 1f) { castTime = 1f; }
        }

        protected virtual void applyHasteToPeriodicTickTime() {
            // Does Nature's Grace affect the duration of Rejuvenate?
            // It says: "casting speed" so I expect not...
            periodicTickTime = periodicTickTimeBeforeHaste / speed;
        }

        protected float OmenProc(float chance, float maxReduction) { return manaCost * (1.0f - chance) + (manaCost < maxReduction ? 0f : chance * (manaCost - maxReduction)); }

        protected float checkOmenlikeProcs() {
            float newManaCost = manaCost;

            //Attempt to handle new SpecialEffect for this
            foreach (Rawr.SpecialEffect effect in cachedStats.SpecialEffects()) {
                if (effect.Trigger == Trigger.SpellCast && (effect.Stats.HealingOmenProc > 0)) {
                    newManaCost = OmenProc(effect.Chance, effect.Stats.HealingOmenProc);
                }
            }

            // Handle case of stat not being created as a SpecialEffect
            //if (cachedStats.ManacostReduceWithin15OnHealingCast > 0) {newManaCost = OmenProc(0.02f, cachedStats.ManacostReduceWithin15OnHealingCast);}

            return newManaCost;
        }
    }
    public class HealingTouch : Spell {
        public HealingTouch(CharacterCalculationsTree calcs, Stats calculatedStats) {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 3f;
            coefDH = 1.62f;
            manaCost = 0.33f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;
            critPercent = calculatedStats.SpellCrit;

            minHeal = 3750f;
            maxHeal = 4428f;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            #region Glyph of Healing Touch
            if (calcs.LocalCharacter.DruidTalents.GlyphOfHealingTouch) {//(calcOpts.glyphOfHealingTouch)
                castTimeBeforeHaste -= 1.5f;
                manaCost *= 1 - 0.25f;
                minHeal *= 1 - 0.5f;
                maxHeal *= 1 - 0.5f;
                coefDH *= 1 - 0.5f;
            }
            #endregion

            #region Idols
            //guessed that it doesnt work with talents
            //z.B.: Idol of the Avian Heart (+136 Healing)
            healingBonus += calculatedStats.HealingTouchFinalHealBonus;

            //z.B.: Idol of Longevity (25 Mana on cast.... -25 Manacost)
            manaCost -= calculatedStats.ReduceHealingTouchCost;
            #endregion

            applyHaste();
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {
            manaCost *= 1 - (druidTalents.Moonglow * 0.03f + druidTalents.TranquilSpirit * 0.02f);

            castTimeBeforeHaste -= 0.1f * druidTalents.Naturalist;

            critPercent += 2f * druidTalents.NaturesMajesty;

            //Living Seed, 30% seed, 33% * points spend (1/3)
            critModifier += 0.1f * druidTalents.LivingSeed * calcOpts.LivingSeedEfficiency / 100f;

            // 6% chance to get Omen of Clarity...
            manaCost *= 1 - 0.06f * druidTalents.OmenOfClarity;

            minHeal *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            maxHeal *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            coefDH += (0.2f * druidTalents.EmpoweredTouch);     // ET is additive from http://elitistjerks.com/f73/t37038-restoration_glyphs/p8/#post1240879 

            coefDH *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);
        }
    }
    public class Regrowth : Spell {
        public Regrowth(CharacterCalculationsTree calcs, Stats calculatedStats) { InitializeRegrowth(calcs, calculatedStats); }
        public Regrowth(CharacterCalculationsTree calcs, Stats calculatedStats, bool withRegrowthActive) {
            InitializeRegrowth(calcs, calculatedStats);

            if (withRegrowthActive && calcs.LocalCharacter.DruidTalents.GlyphOfRegrowth) {//(CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions).glyphOfRegrowth)
                minHeal *= 1.2f;
                maxHeal *= 1.2f;
                periodicTick *= 1.2f;
                coefDH *= 1.2f;
                coefHoT *= 1.2f;
            }
        }
        private void InitializeRegrowth(CharacterCalculationsTree calcs, Stats calculatedStats) {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 2f;
            coefDH = 0.54f; 
            coefHoT = 1.316f / 7f;
            manaCost = 0.29f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;
            critPercent = calculatedStats.SpellCrit;

            minHeal = 2234f;
            maxHeal = 2494f;
            periodicTick = 335f; // 2345 / 7
            periodicTicks = 7f;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            #region Idols
            //z.B.: Idol of the Crescent Goddess (-65 Mana)
            manaCost -= calculatedStats.ReduceRegrowthCost;
            #endregion

            /* Glyph of Regrowth is modelled in the constructor */
            applyHaste();
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {
            periodicTicks += 2 * druidTalents.NaturesSplendor;

            manaCost -=
                manaCost * 0.03f * druidTalents.Moonglow +
                manaCost * 0.2f * druidTalents.TreeOfLife;

            critPercent += 5f * druidTalents.NaturesBounty;
            //Living Seed
            critModifier += 0.1f * druidTalents.LivingSeed * calcOpts.LivingSeedEfficiency / 100f;

            // 6% chance to get Omen of Clarity...
            manaCost *= 1f - 0.06f * druidTalents.OmenOfClarity;

            minHeal *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            maxHeal *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            coefDH *=
                (1f + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            periodicTick *=
                (1f + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            coefHoT *= 
                (1f + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1f + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);
        }
    }
    public class Rejuvenation : Spell {
        public Rejuvenation(CharacterCalculationsTree calcs, Stats calculatedStats) {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 0f;
            coefHoT = 1.879f / 5;
            manaCost = 0.18f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;

            periodicTick = 338f; //1690 / 5 ... newest Rank got 15 seconds.. i hope it's not involed with another coef ..
            periodicTicks = 5f;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            #region Idols etc
            //e.g.: Harold's Rejuvenating Broach 
            healingBonus += calculatedStats.RejuvenationSpellpower;
            //e.g.: Idol of Pure Thoughts
            periodicTick += calculatedStats.RejuvenationHealBonus;

            //e.g.: Idol of Budding Life (-36 Manacost) Idol of Awakening (-106 Manacost)
            manaCost -= calculatedStats.ReduceRejuvenationCost;
            #endregion

            #region Tier 8 (4) SetBonus
            if (calculatedStats.RejuvenationInstantTick > 0.0f) {
                // Set AverageHealingwithCrit = PeriodicTick
                minHeal     = PeriodicTick * calculatedStats.RejuvenationInstantTick;  //Some talents doesn't apply to this instant tick, so it should actually be less than the normal tick, hopefully small enough error
                maxHeal     = PeriodicTick * calculatedStats.RejuvenationInstantTick;
                coefDH      = 0.0f; // PeriodicTick already scaled by SpellPower, so don't scale again
                critPercent = 0.0f;
            }
            #endregion

            #region Tier 9 (4) SetBonus
            critHoTPercent = calculatedStats.SpellCrit * calculatedStats.RejuvenationCrit;
            //Should set  critPercent = critHoTPercent;   to allow instantTick to also be crittable, but cannot have 4 piece setbonus simultanuously
            #endregion

            #region Glyph of Rapid Rejuvenation
            if (calcs.LocalCharacter.DruidTalents.GlyphOfRapidRejuvenation)
            {
                applyHasteToPeriodicTickTime();
            }
            #endregion

            applyHaste();
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {
            periodicTicks += 1 * druidTalents.NaturesSplendor;

            manaCost *= 1 - 0.2f * druidTalents.TreeOfLife - 0.03f * druidTalents.Moonglow;

            // 6% chance to get Omen of Clarity...
            manaCost *= 1 - 0.06f * druidTalents.OmenOfClarity;

            periodicTick *=
                (1 + 0.01f * druidTalents.Genesis + 
                 0.05f * druidTalents.ImprovedRejuvenation + 
                 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);

            coefHoT *= 
                (1 + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1 + 0.01f * druidTalents.Genesis + 
                 0.05f * druidTalents.ImprovedRejuvenation + 
                 0.02f * druidTalents.GiftOfNature) *
                (1 + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1 + 0.06f * druidTalents.TreeOfLife);
        }
    }
    public class Lifebloom : Spell {
        protected float idolHoTBonus = 0f;
        protected float idolDHBonus = 0f;
        private float stackScaling = 1.0f;
        private float stackSize = 1.0f;
        protected float manaRefund = 0.0f;
        public override float PeriodicTick { get { return stackScaling * (periodicTick + (idolHoTBonus + healingBonus) * coefHoT); } }
        public override float AverageHealing {  get { return stackSize * (extraHealing + (minHeal + maxHeal) / 2 + HealingBonus * coefDH); } }
        public override float HealingBonus { get { return healingBonus + idolDHBonus; } set { healingBonus = value; } }
        public override float ManaCost {get { return (base.ManaCost - manaRefund); }/*set { manaCost = value; }*/}
        public Lifebloom(CharacterCalculationsTree calcs, Stats calculatedStats) {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 0f;
            periodicTickTime    = 1f;
            coefHoT             = 0.6684f / 7f;
            manaCost            = 0.28f * TreeConstants.BaseMana; // manaCost without refund
            manaRefund          = 0.14f * TreeConstants.BaseMana;
            healingBonus        = calculatedStats.SpellPower;
            critPercent         = calculatedStats.SpellCrit;

            minHeal = 776f;         // Patch 3.2 nerfs bloom value
            maxHeal = 776f;
            coefDH = 0.645f * 0.8f; // 20 % Nerf

            periodicTick = 53f;
            periodicTicks = 7f;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            #region Idols
            //z.B.: Idol of the Emerald Queen
            idolHoTBonus = calculatedStats.LifebloomTickHealBonus;

            //z.B.: Gladiator's Idol of Tenacity (87 on final heal), haven't one myself, will correct it when i've one
            idolDHBonus = calculatedStats.LifebloomFinalHealBonus;
            #endregion

            if (calcs.LocalCharacter.DruidTalents.GlyphOfLifebloom) { periodicTicks += 1f; } //(calcOpts.glyphOfLifebloom)
            
            manaCost *= (1f-calculatedStats.LifebloomCostReduction);

            applyHaste();
        }

        public Lifebloom(CharacterCalculationsTree calcs, Stats calculatedStats, int numStacks, bool fastStack) : this(calcs, calculatedStats) {
            float newPeriodicTicks = periodicTicks;

            if (numStacks == 1) {
                // Do nothing, already setup
            } else if (numStacks == 2) {
                manaCost *= 2;
                manaRefund *= 2;

                if (!fastStack) {
                    #region Slow LB stacking
                    newPeriodicTicks = periodicTicks * 2 - 1;  // Double number of ticks, but lose 1
                    // N-1 ticks of 1 stack + N ticks of 2 stacks, averaged over total ticks
                    stackScaling = ((periodicTicks - 1) + 2 * periodicTicks) / newPeriodicTicks;
                    #endregion
                } else {
                    #region Fast LB stacking
                    newPeriodicTicks = periodicTicks + 1;  // Stack every tick 
                    // 1 ticks of 1 stack + N ticks of 2 stacks, averaged over total ticks
                    stackScaling = ((1) + 2 * periodicTicks) / newPeriodicTicks;
                    #endregion
                }

                stackSize = 2.0f; // Bloom heal doubled

                periodicTicks = newPeriodicTicks;

                castTime = 2.0f * gcd;
            } else if (numStacks == 3) {
                manaCost *= 3;
                manaRefund *= 3;

                if (!fastStack) {
                    #region Slow LB stacking
                    newPeriodicTicks = periodicTicks * 3 - 2;  // Triple number of ticks, but lose 1 each time
                    // N-1 ticks of 1 stack + N -1 ticks of 2 stacks, averaged over total ticks
                    stackScaling = ((periodicTicks - 1) + 2 * (periodicTicks - 1) + 3 * periodicTicks) / newPeriodicTicks;
                    #endregion
                } else {
                    #region Fast LB stacking
                    newPeriodicTicks = periodicTicks + 2;  // Stack every tick 
                    // 1 ticks of 1 stack + 1 ticks of 2 stacks, averaged over total ticks
                    stackScaling = ((1) + 2 * (1) + 3 * periodicTicks) / newPeriodicTicks;
                    #endregion
                }

                stackSize *= 3.0f; // Bloom heal trippled

                periodicTicks = newPeriodicTicks;

                castTime = 3.0f * gcd;
            }
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {
            periodicTicks += 2f * druidTalents.NaturesSplendor;

            gcdBeforeHaste -= 1.5f * 0.02f * druidTalents.GiftOfTheEarthmother;

            manaCost *= (1f - 0.2f * druidTalents.TreeOfLife);

            // 6% chance to get Omen of Clarity...
            manaCost *= 1f - 0.06f * druidTalents.OmenOfClarity;

            periodicTick *=
                (1f + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            coefHoT *= 
                (1f + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1f + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            minHeal *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            maxHeal *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            coefDH *=
                (1f + 0.04f * druidTalents.EmpoweredRejuvenation) *
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter) *
                (1f + 0.06f * druidTalents.TreeOfLife);
        }
    }
    public class LifebloomStack : Lifebloom {
        public LifebloomStack(CharacterCalculationsTree calcs, Stats calculatedStats) : base(calcs, calculatedStats) {
            periodicTick  *= 3f;
            periodicTicks -= 1f; // Keep a stack alive
            coefHoT       *= 3f;
            minHeal        = 0f;
            maxHeal        = 0f;
            coefDH         = 0f;
            critPercent    = 0f;
            //CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;
            manaRefund     = 0f; // manaCost is now without refund   
        }
    }
    public class WildGrowth : Spell {
        float[][] tickRanks = new float[][] { 
             new float[] {176f, 157f, 140f, 123f, 105f, 88f, 70f}, //mostly observation
             //quessed..
             new float[] {295f, 263f, 234f, 206f, 176f, 147f, 117f} //Rank 4
        };
        public int maxTargets;
        /// <summary>returns the Tick of WG, Ranks: 0 = Rank 2, 1 = Rank 4, valid index - 0 to 6</summary>
        public float getTick(int rank, int index) { return healingBonus * coefHoT + tickRanks[rank][index];  }
        public WildGrowth(CharacterCalculationsTree calcs, Stats calculatedStats) {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 0f;
            coefHoT = 0.8057f / 7f; 
            manaCost = 0.23f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;

            periodicTick     = 206f; // 1442 / 7
            periodicTicks    =   7f;
            periodicTickTime =   1f;
            maxTargets       =   5;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            applyHaste();
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {
            manaCost *= (1f - 0.2f * druidTalents.TreeOfLife);

            // 6% chance to get Omen of Clarity...
            manaCost *= 1f - 0.06f * druidTalents.OmenOfClarity;

            // Glyph of Wild Growth
            if (druidTalents.GlyphOfWildGrowth)
              maxTargets += 1;

            coefHoT *=
                (1f + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.06f * druidTalents.TreeOfLife) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife);

            float basecoef = 
                (1f + 0.01f * druidTalents.Genesis + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.06f * druidTalents.TreeOfLife) *
                (1f + 0.02f * druidTalents.MasterShapeshifter);

            periodicTick *= basecoef;
            for (int i = 0; i < 7; i++) { 
                tickRanks[0][i] *= basecoef;
                tickRanks[1][i] *= basecoef;
            }
        }
    }
    public class Nourish : Spell {
        float NourishBonusPerHoTGlyphs;
        public Nourish(CharacterCalculationsTree calcs, Stats calculatedStats) { InitializeNourish(calcs, calculatedStats); }
        public Nourish(CharacterCalculationsTree calcs, Stats calculatedStats, int hotsActive) {
            InitializeNourish(calcs, calculatedStats);
            if (hotsActive>0) {
                minHeal *= 1.2f + (calculatedStats.NourishBonusPerHoT + NourishBonusPerHoTGlyphs) * hotsActive;
                maxHeal *= 1.2f + (calculatedStats.NourishBonusPerHoT + NourishBonusPerHoTGlyphs) * hotsActive;
                coefDH  *= 1.2f + (calculatedStats.NourishBonusPerHoT + NourishBonusPerHoTGlyphs) * hotsActive;
            }
        }
        private void InitializeNourish(CharacterCalculationsTree calcs, Stats calculatedStats) {
            CalculationOptionsTree calcOpts = (CalculationOptionsTree)calcs.LocalCharacter.CalculationOptions;

            base.Initialize(calcs, calculatedStats);

            #region Base Values
            castTimeBeforeHaste = 1.5f;
            //coefDH = 0.6611f; // Spreadsheet says .69, wowwiki says .6611, 1.5/3.5 = .43, confused!
            //coefDH = 0.67305f; // Value used in TreeCalcs
            coefDH = 0.671429f; // Best guess based on tests reported in workitem http://rawr.codeplex.com/WorkItem/View.aspx?WorkItemId=13809
            manaCost = 0.18f * TreeConstants.BaseMana;
            healingBonus = calculatedStats.SpellPower;
            critPercent = calculatedStats.SpellCrit;

            minHeal = 1883f;
            maxHeal = 2187f;
            NourishBonusPerHoTGlyphs = 0.0f;
            #endregion

            // Seems to apply before talents
            manaCost -= calculatedStats.SpellsManaReduction;

            #region Idols
            // Idol of Flourishing Life
            healingBonus += calculatedStats.NourishSpellpower;
            #endregion

            #region Tier 9 2 piece Set Bonus
            critPercent += (calculatedStats.NourishCritBonus * 100.0f); // Percent is range 0-100
            #endregion

            calculateTalents(calcs.LocalCharacter.DruidTalents, calcOpts);

            applyHaste();
        }
        private void calculateTalents(DruidTalents druidTalents, CalculationOptionsTree calcOpts) {
            manaCost *= (1f - druidTalents.TranquilSpirit * 0.02f - druidTalents.Moonglow * 0.03f);

			critPercent += 2f * druidTalents.NaturesMajesty;
            critPercent += 5f * druidTalents.NaturesBounty;

            //Living Seed, 30% seed, 33% * points spend (1/3)
            //if (calcOpts.useLivingSeedAsCritMultiplicator)
            critModifier += 0.1f * druidTalents.LivingSeed * calcOpts.LivingSeedEfficiency / 100f;

            // 6% chance to get Omen of Clarity...
            manaCost *= 1f - 0.06f * druidTalents.OmenOfClarity;
                
            minHeal *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            maxHeal *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            coefDH += (0.1f * druidTalents.EmpoweredTouch);     // From 3.2 Empowered Touch also boosts Nourish
            // Assume also additive, also see http://elitistjerks.com/f73/t37038-restoration_glyphs/p8/#post1240879 
            // This is also the value TreeCalcs uses at the moment (8th december 2009)

            coefDH *=
                (1f + 0.02f * druidTalents.GiftOfNature) *
                (1f + 0.02f * druidTalents.MasterShapeshifter * druidTalents.TreeOfLife) *
                (1f + 0.06f * druidTalents.TreeOfLife);

            if (druidTalents.GlyphOfNourish) { NourishBonusPerHoTGlyphs = 0.06f; }
        }
    }
    public class Swiftmend : Spell {
        public float regrowthUseChance = 0.0f;
        public float rejuvUseChance = 0.0f;
        public float regrowthTicksLost = 0.0f;
        public float rejuvTicksLost = 0.0f;
        public Swiftmend(CharacterCalculationsTree calcs, Stats calculatedStats, Spell Rejuv, Spell Regrowth) {
            base.Initialize(calcs, calculatedStats);

            regrowthUseChance = rejuvUseChance = regrowthTicksLost = rejuvTicksLost = 0.0f;

            #region Base Values
            castTimeBeforeHaste = gcd;
            coefDH = 0;
            manaCost = 0.16f * TreeConstants.BaseMana;
            healingBonus = 0f;
            critPercent = calculatedStats.SpellCrit;

            minHeal = 0f;
            maxHeal = 0f;
            #endregion

            if (Rejuv == null) {
                if (Regrowth == null) {
                    // No HoTs, so Swiftmend not possible
                }else{
                    // Case of only Regrowth
                    minHeal = 6 * Regrowth.PeriodicTick;
                    maxHeal = minHeal;
                    regrowthUseChance = 1.0f;
                    if (!calcs.LocalCharacter.DruidTalents.GlyphOfSwiftmend){
                        regrowthTicksLost = (Regrowth.PeriodicTicks + 1f) / 2.0f;      // If cast randomly, consume half of the ticks
                    }
                }
            }else if (Regrowth == null){
                // Case of only Rejuv
                minHeal = 4f * Rejuv.PeriodicTick;
                maxHeal = minHeal;
                rejuvUseChance = 1f;
                if (!calcs.LocalCharacter.DruidTalents.GlyphOfSwiftmend){
                    rejuvTicksLost = (Rejuv.PeriodicTicks + 1f)/ 2.0f;      // If cast randomly, consume half of the ticks
                }
            }else{
                // Case of both active

                //TODO: Find a formula to calculate this, instead of "numerical integration"
                float selectedRejuv,selectedRegrowth,lostRejuvTicks,lostRegrowthTicks = 0;

                /* Numeric integration to estimate this, considering haste
                float regrowthTimeLeft, rejuvTimeLeft;
                float validScenario = 0;
                // castPoint is the point inside the Regrowth Duration where you cast Swiftmend
                // thus casting Regrowth from -Regrowth.CastTime to 0 and again (Regrowth.Duration-Regrowth.CastTime) to Regrowth.Duration
                // rejuvOffset is the offset relative to Regrowth start, that Rejuv needs to be refreshed to keep 100% uptime
                // rejuvOffset = 0.0f, would mean need to cast rejuv directly after casting regrowth
                // Assume rejuvOffset drifts over all possible values over the fight (not valid if they are nice multiples to form a nice rotation)
                // Assume castPoint is random, no smart casting and equally probable any time your not refreshing rejuv or regrowth
                //  (this might not be valid, since just after landing the regrowth, the tank got a healing burst and you possibly don't
                //  want to directly heal him again, unless it was an emergency)
                for (float castPoint = 0.0f; castPoint < Regrowth.Duration; castPoint += 0.1f)
                    for (float rejuvOffset = 0.0f; rejuvOffset < Rejuv.Duration; rejuvOffset += 0.1f)
                    {
                        // check for valid scenario
                        if (castPoint > Regrowth.Duration - Regrowth.CastTime)
                        {
                            // Possible but not ideal, since it means Regrowth downtime. But if you don't have Glyph, this migth be ideal time to cast.
                            // So leave it valid for now
                        }
                        if ((rejuvOffset > Rejuv.Duration - Regrowth.CastTime) && (rejuvOffset < Rejuv.Duration))
                        {
                            // Not possible, since it means at time -1sec, while you where casting your last Regrowth, 
                            //    you where also casting your last Rejuv
                            continue;
                        }
                        if ( (castPoint >= rejuvOffset) && (castPoint < rejuvOffset + Rejuv.gcd) )
                        {
                            // Not possible, since your still on GCD from rejuv
                            continue;
                        }
                        validScenario += 1;
                        regrowthTimeLeft = Regrowth.Duration - castPoint;
                        rejuvTimeLeft = rejuvOffset - castPoint;
                        if (rejuvTimeLeft < 0.0f)
                        {
                            rejuvTimeLeft += Rejuv.Duration;
                        }

                        if (regrowthTimeLeft < rejuvTimeLeft)
                        {
                            // Picking regrowth
                            selectedRegrowth += 1;
                            lostRegrowthTicks += (float) Math.Ceiling(regrowthTimeLeft / 3.0f);
                        }
                        else
                        {
                            // Picking rejuv
                            selectedRejuv += 1;
                            lostRejuvTicks += (float) Math.Ceiling(rejuvTimeLeft / 3.0f);
                        }
                    }
                regrowthUseChance = selectedRegrowth / validScenario * (Rejuv.Duration/Regrowth.Duration);
                rejuvUseChance = selectedRejuv / validScenario * (Rejuv.Duration / Regrowth.Duration) + (Regrowth.Duration - Rejuv.Duration) / Regrowth.Duration;
                */

                regrowthUseChance = Rejuv.Duration / Regrowth.Duration * 0.5f;
                rejuvUseChance = (Regrowth.Duration - Rejuv.Duration) / Regrowth.Duration + Rejuv.Duration / Regrowth.Duration * 0.5f;
                lostRejuvTicks = (0.5f * (Rejuv.PeriodicTicks + 1f) * (Regrowth.Duration - Rejuv.Duration) / Regrowth.Duration) + (Rejuv.PeriodicTicks * 10f / 24f) * 0.5f * (Rejuv.Duration / Regrowth.Duration);
                selectedRejuv = rejuvUseChance;
                lostRegrowthTicks = ((Rejuv.PeriodicTicks - 1f)/ 2f);
                selectedRegrowth = 1f;

                minHeal = (6f * regrowthUseChance * Regrowth.PeriodicTick + 4f * rejuvUseChance * Rejuv.PeriodicTick);
                maxHeal = minHeal;

                if (!calcs.LocalCharacter.DruidTalents.GlyphOfSwiftmend) {
                    rejuvTicksLost = lostRejuvTicks / selectedRejuv;
                    regrowthTicksLost = lostRegrowthTicks / selectedRegrowth;
                }
            }
            #region Nightsong (Tier 8) 2 item set bonus
            minHeal *= (1.0f + calculatedStats.SwiftmendBonus);
            maxHeal *= (1.0f + calculatedStats.SwiftmendBonus);
            #endregion

            applyHaste();
        }
    }
}
